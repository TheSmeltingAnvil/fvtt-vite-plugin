import path from "path"
import * as Vite from "vite"
import { FoundryvttOptions, ResolvedAssetsOptions, ResolvedFoundryvttOptions } from "../_types"
import { Manifest, ManifestInfo } from "@foundryvtt/utils"

export async function resolveOptions(
  options: FoundryvttOptions,
  manifestInfo: ManifestInfo,
): Promise<ResolvedFoundryvttOptions> {
  const resolvedOptions = { ...options } as ResolvedFoundryvttOptions

  // Resolve manifest and load it
  resolvedOptions.manifestInfo = manifestInfo
  const manifest = await manifestInfo.manifest()

  // Resolve assets options
  resolvedOptions.assets = (() => {
    switch (typeof options.assets) {
      case "undefined":
        return []
      case "object":
        return (Array.isArray(options.assets) ? options.assets : [options.assets]).map((o) => ({
          assetType: o.assetType || "",
          copyToOutDir: !!o.copyToOutDir,
          exclude: Array.isArray(o.exclude) ? o.exclude : [...(o.exclude || [])],
          pattern: Array.isArray(o.pattern) ? o.pattern : [...(o.pattern || [])],
          reload: typeof o.reload === "string" ? o.reload : false,
          rename: o.rename,
          serve: !!o.serve,
        }))
      default:
        throw new Error("Invalid assets options")
    }
  })()
  resolvedOptions.assets = [...resolvedOptions.assets, ...defaultAssetsOptions]

  // Set default variables for replacement
  options.variables = options.variables || {}
  options.variables["ID"] = manifest!.id
  options.variables["VERSION"] = manifest!.version
  options.variables["TITLE"] = manifest!.title
  const variables = options.variables
  delete options.variables
  resolvedOptions.replace = (source: string) => {
    for (const [variable, value] of Object.entries(variables)) {
      source = source.replaceAll(`$${variable}$`, value)
    }
    return source
  }

  // Functions to generate output file names
  resolvedOptions.scriptFileNames = (name: string) => {
    return `${name}.mjs`
  }
  resolvedOptions.styleFileNames = (name: string) => {
    return `${name}.css`
  }

  // Create mapping from original file names to output file names
  const esmodules = (manifest.esmodules ?? []).reduce(
    (acc, originalFileName) => {
      const { dir, name } = path.posix.parse(originalFileName)
      const name2 = path.posix.join(dir, name)
      acc[originalFileName] = resolvedOptions.scriptFileNames(name2)
      return acc
    },
    {} as Record<string, string>,
  )
  const scripts = (manifest.scripts ?? []).reduce(
    (acc, originalFileName) => {
      const { dir, name } = path.posix.parse(originalFileName)
      const name2 = path.posix.join(dir, name)
      acc[originalFileName] = resolvedOptions.scriptFileNames(name2)
      return acc
    },
    {} as Record<string, string>,
  )
  const styles = (manifest.styles ?? []).reduce(
    (acc, originalFileName) => {
      const { dir, name } = path.posix.parse(originalFileName)
      const name2 = path.posix.join(dir, name)
      acc[originalFileName] = resolvedOptions.styleFileNames(name2)
      return acc
    },
    {} as Record<string, string>,
  )

  resolvedOptions.entries = { ...esmodules, ...scripts, ...styles }

  return resolvedOptions
}

// The Foundry VTT manifest is the source of truth for what files are included in the build.
// This function rewrites the file paths in the manifest to match the output file names
// generated by Vite/Rollup, based on the input file names and the output configuration.
export function resolveManifest(manifest: Manifest, config: Vite.UserConfig | Vite.ResolvedConfig): Manifest {
  const resolvedManifest: Partial<Manifest> = { ...manifest }

  const scriptFileNames =
    createFunction(config.build?.rolldownOptions?.output, "entryFileNames") ??
    createFunction(config.build?.rolldownOptions?.output, "chunkFileNames") ??
    ((name: string, extname: string) => `${name}${extname}`)

  const styleFileNames =
    createFunction(config.build?.rolldownOptions?.output, "cssEntryFileNames") ??
    createFunction(config.build?.rolldownOptions?.output, "cssChunkFileNames") ??
    createFunction(config.build?.rolldownOptions?.output, "chunkFileNames") ??
    ((name: string, extname: string) => `${name}${extname}`)

  resolvedManifest.esmodules = manifest.esmodules.map((fileName: string) => {
    fileName = useInputName(fileName, config)
    const { dir, name, ext } = path.parse(fileName)
    fileName = path.posix.join(dir, scriptFileNames(name, ext))
    if (fileName.endsWith(".ts")) {
      return fileName.replace(/\.ts$/, ".js")
    }
    return fileName
  })
  resolvedManifest.scripts = manifest.scripts.map((fileName: string) => {
    fileName = useInputName(fileName, config)
    const { dir, name, ext } = path.parse(fileName)
    fileName = path.posix.join(dir, scriptFileNames(name, ext))
    if (fileName.endsWith(".ts")) {
      return fileName.replace(/\.ts$/, ".js")
    }
    return fileName
  })
  resolvedManifest.styles = manifest.styles.map((fileName: string) => {
    fileName = useInputName(fileName, config)
    const { dir, name, ext } = path.parse(fileName)
    fileName = path.posix.join(dir, styleFileNames(name, ext))
    if (fileName.endsWith(".scss")) {
      return fileName.replace(/\.scss$/, ".css")
    }
    if (fileName.endsWith(".sass")) {
      return fileName.replace(/\.sass$/, ".css")
    }
    if (fileName.endsWith(".less")) {
      return fileName.replace(/\.less$/, ".css")
    }
    return fileName
  })
  resolvedManifest.languages = manifest.languages.map((lang) => ({
    ...lang,
    path: lang.path.replace(/\.ya?ml$/, ".json"),
  }))

  return resolvedManifest as Manifest
}

function useInputName(fileName: string, config: Vite.UserConfig | Vite.ResolvedConfig): string {
  if (config.build?.rolldownOptions?.input) {
    const input = Object.entries(config.build.rolldownOptions.input)
    const name = input.find(([_, value]) => value === fileName)?.[0]
    const { ext } = path.parse(fileName)
    return name ? name + ext : fileName
  }
  return fileName
}

//export function generateManifest(manifest: Manifest, resolvedConfig: Vite.ResolvedConfig) {
//  const entryFileNames = createFunction(resolvedConfig.build.rolldownOptions.output, "entryFileNames")
//  const cssEntryFileNames = createFunction(resolvedConfig.build.rolldownOptions.output, "cssEntryFileNames")

//  function getOutputFileName(name: string, fileName: string) {
//    if (path.extname(fileName) === ".ts") {
//      return entryFileNames(name, ".mjs")
//    }
//    if (
//      path.extname(fileName) === ".scss" ||
//      path.extname(fileName) === ".sass" ||
//      path.extname(fileName) === ".less"
//    ) {
//      return cssEntryFileNames(name, ".css")
//    }
//    return fileName
//  }

//  const input = [...manifest.esmodules, ...manifest.scripts, ...manifest.styles].map((fileName) => {
//    const { dir, name } = path.parse(fileName)
//    return { name, fileName, baseName: path.posix.join(dir, name) }
//  })

//  let source = JSON.stringify(manifest, null, 2)
//  for (const { name, fileName, baseName } of input) {
//    source = source.replaceAll(fileName, getOutputFileName(name, baseName))
//  }
//  // Also replace .yml/.yaml with .json
//  source = source.replaceAll(/\.ya?ml\b/g, ".json")
//  return source
//}

function createFunction(
  output: Vite.Rolldown.OutputOptions | Vite.Rolldown.OutputOptions[] | undefined,
  key: "entryFileNames" | "cssEntryFileNames" | "chunkFileNames" | "cssChunkFileNames",
) {
  if (!output) return (name: string, extname: string) => `${name}${extname}`

  const config = Array.isArray(output) ? output.find((o) => key in o)?.[key] : output[key]
  if (!config) return undefined

  if (typeof config === "string") {
    return (name: string, extname: string) => {
      return config.replace("[name]", name).replace("[extname]", extname)
    }
  }

  if (typeof config === "function") {
    return (name: string, _extname: string) => {
      return config({ name } as Vite.Rolldown.PreRenderedChunk)
    }
  }

  return undefined
}

const defaultAssetsOptions: ResolvedAssetsOptions[] = [
  {
    assetType: "language",
    pattern: ["**/*.json", "**/*.yml", "**/*.yaml"],
    exclude: ["system.*", "module.*", "package.json", "tsconfig.*", "packs/**"],
    copyToOutDir: true,
    serve: true,
    reload: false,
    rename: (name: string) => name.replace(/\.(yml|yaml)$/, ".json"),
  },
  {
    assetType: "template",
    pattern: ["**/*.hbs", "**/*.htm", "**/*.html"],
    exclude: [],
    copyToOutDir: true,
    serve: false,
    reload: "template",
    rename: undefined,
  },
]
